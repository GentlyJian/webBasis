<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>

</body>
<script>
    // 从数组中提取值，按照对应位置，对变量赋值
    // var [a, b, c] = [1, 2, 3];
    // var a = [1, 2, 3];
    // console.log(a);
    // console.log(b);
    // console.log(c);

    // ...的用法 ...表示后面剩余数的 数组
    // let [head, ...tail] = [1, 2, 3, 4]
    // console.log(head);
    // console.log(tail);

    //解构不成功 没有解构的值会被定义成undefined,...则是[]空数组
    // let [bar, foo, ...arr] = [1,];
    // console.log(bar); //1
    // console.log(foo); //undefined
    // console.log(arr); //[]

    //不完全解构，可以解构对应位置上的值
    // let [a, [b], d] = [1, [2, 3], 4];
    // a // 1
    // b // 2
    // d // 4

    //等号右边不是数组的情况 那么将会报错 因为右边对象不具有Iterator接口

  /*   //function*是什么
    // 生成器函数的行为与普通函数并不相同，表现为如下3点：

    // 1. 通过new运算符或函数调用的形式调用生成器函数，均会返回一个生成器实例；

    // 2. 通过new运算符或函数调用的形式调用生成器函数，均不会马上执行函数体的代码；

    // 3. 必须调用生成器实例的next方法才会执行生成器函数体的代码。

    //yield是什么
    // yield是ES6的新关键字，使生成器函数执行暂停，yield关键字后面的表达式的值返回给生成器的调用者。它可以被认为是一个基于生成器的版本的return关键字。
    // yield关键字实际返回一个IteratorResult（迭代器）对象，它有两个属性，value和done，分别代表返回值和是否完成。
    // yield无法单独工作，需要配合generator(生成器)的其他函数，如next，懒汉式操作，展现强大的主动控制特性。
    // 如果你看到某个函数中有yield，说明这个函数已经是个生成器了
    // yield可以用来加强控制，懒汉式加载
    // 调用函数指针和调用生成器是两码事，注意上面的运行结果，countAppleSales和myArr。
    // 需要next()函数配合使用，每次调用返回两个值：分别是value和done，代表迭代结果和是否完成
    // 函数next()是个迭代器对象，传参可以缺省，默认调用函数。

    function* fibs() {
        let a = 0;
        let b = 1;
        while (true) {
            yield a;
            [a, b] = [b, a + b];
        }
    }

    let [first, second, third, fourth, fifth, sixth] = fibs();
    first;
    sixth // 5  */


</script>

</html>